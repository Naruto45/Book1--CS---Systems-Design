<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI RAG Chatbot with Vector Database</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

            :root {
        /* Color Palette */
        --primary-color: #3B82F6;
        --primary-dark: #2563EB;
        --primary-light: #60A5FA;
        --secondary-color: #10B981;
        --accent-color: #F59E0B;
        --warning-color: #EF4444;
        
        /* Neutral Colors */
        --white: #FFFFFF;
        --gray-50: #F9FAFB;
        --gray-100: #F3F4F6;
        --gray-200: #E5E7EB;
        --gray-300: #D1D5DB;
        --gray-400: #9CA3AF;
        --gray-500: #6B7280;
        --gray-600: #4B5563;
        --gray-700: #374151;
        --gray-800: #1F2937;
        --gray-900: #111827;
        
        /* Dark Theme Colors */
        --dark-bg: #0F172A;
        --dark-surface: #1E293B;
        --dark-surface-2: #334155;
        --dark-border: #475569;
        --dark-text: #F1F5F9;
        --dark-text-secondary: #CBD5E1;
        
        /* Legacy aliases for backward compatibility */
        --bg-color: var(--dark-bg);
        --surface-color: var(--dark-surface);
        --surface-2: var(--dark-surface-2);
        --border-color: var(--dark-border);
        --text-color: var(--dark-text);
        --text-secondary: var(--dark-text-secondary);
        --text-muted: #94A3B8;

        /* Typography */
        --font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        --font-size-xs: 0.75rem;
        --font-size-sm: 0.875rem;
        --font-size-base: 1rem;
        --font-size-lg: 1.125rem;
        --font-size-xl: 1.25rem;
        --font-size-2xl: 1.5rem;
        --font-size-3xl: 1.875rem;
        --font-size-4xl: 2.25rem;
        --font-size-5xl: 3rem;
        
        /* Spacing */
        --spacing-xs: 0.25rem;
        --spacing-sm: 0.5rem;
        --spacing-md: 1rem;
        --spacing-lg: 1.5rem;
        --spacing-xl: 2rem;
        --spacing-2xl: 3rem;
        --spacing-3xl: 4rem;
        
        /* Border Radius */
        --radius-sm: 0.25rem;
        --radius-md: 0.375rem;
        --radius-lg: 0.5rem;
        --radius-xl: 0.75rem;
        --radius-2xl: 1rem;
        
        /* Shadows */
        --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        
        /* Transitions */
        --transition-fast: 150ms ease-in-out;
        --transition-normal: 250ms ease-in-out;
        --transition-slow: 350ms ease-in-out;
        
        /* Layout */
        --max-width: 1200px;
        --sidebar-width: 280px;
        --header-height: 70px;
    }

        body {
            font-family: var(--font-family);
            font-size: var(--font-size-base);
            line-height: 1.6;
            color: var(--dark-text);
            background: linear-gradient(135deg, var(--dark-bg) 0%, #1E293B 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* ===== NAVIGATION ===== */
        .navbar {
            background: rgba(15, 23, 42, 0.98);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-bottom: 1px solid rgba(71, 85, 105, 0.3);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 9999;
            height: 80px;
            display: flex;
            align-items: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            transition: all 0.3s ease;
        }
        
        .navbar.scrolled {
            background: rgba(15, 23, 42, 0.95);
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.2);
            height: 70px;
        }
        
        .nav-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 2rem;
        }
        
        .nav-brand {
            display: flex;
            flex-direction: column;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        
        .nav-brand:hover {
            transform: translateY(-1px);
        }
        
        .nav-brand h1 {
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--white);
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0;
            line-height: 1.2;
            transition: all 0.3s ease;
        }
        
        .nav-brand .subtitle {
            font-size: 0.75rem;
            color: var(--dark-text-secondary);
            font-weight: 500;
            letter-spacing: 0.5px;
            margin-top: 2px;
            opacity: 0.9;
        }
        
        .nav-menu {
            display: flex;
            gap: var(--spacing-xl);
            align-items: center;
        }
        
        .nav-link {
            color: var(--dark-text-secondary);
            font-weight: 500;
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--radius-lg);
            transition: var(--transition-fast);
            text-decoration: none;
        }
        
        .nav-link:hover {
            color: var(--white);
            background: rgba(59, 130, 246, 0.1);
            border-bottom: none;
        }
        
        .nav-link.active {
            color: var(--primary-light);
            background: rgba(59, 130, 246, 0.2);
        }
        
        /* ===== DROPDOWN NAVIGATION ===== */
        .nav-dropdown {
            position: relative;
            display: inline-block;
        }
        
        .dropdown-toggle {
            background: none;
            border: none;
            color: var(--dark-text-secondary);
            font-weight: 500;
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--radius-lg);
            transition: var(--transition-fast);
            cursor: pointer;
            font-family: inherit;
            font-size: inherit;
        }
        
        .dropdown-toggle:hover {
            color: var(--white);
            background: rgba(59, 130, 246, 0.1);
        }
        
        .dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: var(--dark-surface);
            border: 1px solid var(--dark-border);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-xl);
            min-width: 300px;
            z-index: 1000;
            padding: var(--spacing-sm);
        }
        
        .nav-dropdown:hover .dropdown-content {
            display: block;
        }
        
        .dropdown-content a {
            display: block;
            padding: var(--spacing-sm) var(--spacing-md);
            color: var(--dark-text-secondary);
            text-decoration: none;
            border-radius: var(--radius-md);
            transition: var(--transition-fast);
            font-size: var(--font-size-sm);
            margin-bottom: var(--spacing-xs);
        }
        
        .dropdown-content a:hover {
            background: rgba(59, 130, 246, 0.1);
            color: var(--primary-light);
        }
        
        .nav-toggle {
            display: none;
            flex-direction: column;
            cursor: pointer;
            gap: 4px;
        }
        
        .nav-toggle span {
            width: 25px;
            height: 3px;
            background: var(--white);
            border-radius: 2px;
            transition: var(--transition-fast);
        }

        /* ===== MAIN CONTENT ===== */
        .main-content {
            margin-top: 80px;
            min-height: calc(100vh - 80px);
            padding: 2rem 0;
        }

        .container {
            max-width: var(--max-width);
            margin: 0 auto;
            padding: var(--spacing-lg);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .header p {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        .setup-panel {
            background: var(--surface-color);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
        }

        .api-key-input {
            width: 100%;
            padding: 12px;
            background: var(--surface-2);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-color);
            font-size: 14px;
            margin-bottom: 10px;
        }

        .api-key-input::placeholder {
            color: var(--text-muted);
        }

        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
        }

        .status-ready {
            background: rgba(16, 185, 129, 0.1);
            color: var(--secondary-color);
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        .status-waiting {
            background: rgba(245, 158, 11, 0.1);
            color: var(--accent-color);
            border: 1px solid rgba(245, 158, 11, 0.3);
        }

        .chat-container {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            height: 70vh;
        }

        .sidebar {
            background: var(--surface-color);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--border-color);
            overflow-y: auto;
        }

        .sidebar h3 {
            margin-bottom: 15px;
            color: var(--text-color);
            font-size: 1.1rem;
        }

        .knowledge-stats {
            background: var(--surface-2);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .stat-label {
            color: var(--text-secondary);
        }

        .stat-value {
            color: var(--text-color);
            font-weight: 500;
        }

        .chat-panel {
            background: var(--surface-color);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .message {
            margin-bottom: 20px;
            display: flex;
            gap: 12px;
        }

        .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 14px;
            flex-shrink: 0;
        }

        .user-avatar {
            background: var(--primary-color);
        }

        .ai-avatar {
            background: var(--secondary-color);
        }

        .message-content {
            flex: 1;
        }

        .message-text {
            background: var(--surface-2);
            padding: 12px 16px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            line-height: 1.6;
        }

        .message-text h1, .message-text h2, .message-text h3 {
            margin: 10px 0 8px 0;
            color: var(--primary-light);
        }

        .message-text h1 { font-size: 1.4rem; }
        .message-text h2 { font-size: 1.2rem; }
        .message-text h3 { font-size: 1.1rem; }

        .message-text p {
            margin: 8px 0;
        }

        .message-text ul, .message-text ol {
            margin: 8px 0;
            padding-left: 20px;
        }

        .message-text li {
            margin: 4px 0;
        }

        .message-text code {
            background: rgba(59, 130, 246, 0.1);
            color: var(--primary-light);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9em;
        }

        .message-text pre {
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            margin: 12px 0;
            overflow-x: auto;
        }

        .message-text pre code {
            background: none;
            padding: 0;
            color: var(--text-color);
            font-size: 0.85em;
        }

        .message-text strong {
            color: var(--text-color);
            font-weight: 600;
        }

        .message-text em {
            color: var(--text-secondary);
            font-style: italic;
        }

        .user-message .message-text {
            background: var(--primary-color);
            color: white;
            margin-left: auto;
            max-width: 80%;
        }

        .message-meta {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 4px;
        }

        .sources {
            margin-top: 10px;
            padding: 10px;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }

        .sources-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 5px;
        }

        .source-item {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 2px;
        }

        .chat-input-container {
            padding: 20px;
            border-top: 1px solid var(--border-color);
        }

        .chat-input-wrapper {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .chat-input {
            flex: 1;
            padding: 12px 16px;
            background: var(--surface-2);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            color: var(--text-color);
            font-size: 14px;
            resize: none;
            min-height: 44px;
            max-height: 120px;
        }

        .chat-input::placeholder {
            color: var(--text-muted);
        }

        .send-button {
            padding: 12px 20px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .send-button:hover:not(:disabled) {
            background: var(--primary-dark);
        }

        .send-button:disabled {
            background: var(--text-muted);
            cursor: not-allowed;
        }

        .loading {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: var(--text-secondary);
            font-style: italic;
        }

        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-top: 2px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .upload-section {
            margin-top: 20px;
            padding: 15px;
            background: var(--surface-2);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .upload-button {
            width: 100%;
            padding: 10px;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            margin-bottom: 10px;
        }

        .file-input {
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: var(--border-color);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: var(--secondary-color);
            width: 0%;
            transition: width 0.3s ease;
        }

        /* ===== RESPONSIVE DESIGN ===== */
        @media (max-width: 768px) {
            .nav-menu {
                display: none;
            }
            
            .nav-menu.active {
                display: flex;
                flex-direction: column;
                position: absolute;
                top: 100%;
                left: 0;
                right: 0;
                background: var(--dark-surface);
                border: 1px solid var(--dark-border);
                border-radius: var(--radius-lg);
                box-shadow: var(--shadow-xl);
                padding: var(--spacing-lg);
                z-index: 1000;
            }
            
            .nav-dropdown {
                width: 100%;
            }
            
            .dropdown-content {
                position: static;
                display: block;
                box-shadow: none;
                border: none;
                background: transparent;
                padding: var(--spacing-sm) 0;
            }
            
            .nav-dropdown:hover .dropdown-content,
            .nav-dropdown.active .dropdown-content {
                display: block;
            }
            
            .nav-toggle {
                display: flex;
            }

            .chat-container {
                grid-template-columns: 1fr;
                height: auto;
            }
            
            .sidebar {
                order: 2;
            }
            
            .chat-panel {
                order: 1;
                height: 60vh;
            }
        }

        .error-message {
            background: rgba(239, 68, 68, 0.1);
            color: var(--warning-color);
            padding: 10px;
            border-radius: 6px;
            border: 1px solid rgba(239, 68, 68, 0.3);
            margin-top: 10px;
            font-size: 14px;
        }

        .embedding-status {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 5px;
        }

        .documents-section {
            margin-top: 20px;
            padding: 15px;
            background: var(--surface-2);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .documents-list {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 10px;
        }

        .document-item {
            padding: 8px;
            background: var(--bg-color);
            border-radius: 6px;
            margin-bottom: 6px;
            border: 1px solid var(--border-color);
            font-size: 12px;
        }

        .document-name {
            font-weight: 500;
            color: var(--text-color);
            margin-bottom: 2px;
        }

        .document-meta {
            color: var(--text-muted);
            font-size: 10px;
        }

        .no-documents {
            color: var(--text-muted);
            font-size: 12px;
            text-align: center;
            padding: 20px;
            font-style: italic;
        }

        .list-docs-button {
            width: 100%;
            padding: 8px;
            background: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 12px;
        }

        .list-docs-button:hover {
            background: rgba(16, 185, 129, 0.8);
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-brand">
                <h1>BlackArmorAI LMS: CS with Python & System Design Thinking</h1>
                <span class="subtitle">Complete Development Guide</span>
            </div>
            <div class="nav-menu">
                <a href="book-website/index.html" class="nav-link">Home</a>
                <div class="nav-dropdown">
                    <button class="nav-link dropdown-toggle">Chapters</button>
                    <div class="dropdown-content">
                        <a href="book-website/01-setting-up-python.html">Chapter 1: Setting Up Python</a>
                        <a href="book-website/02-using-chatgpt.html">Chapter 2: Using ChatGPT</a>
                        <a href="book-website/03-using-cursor.html">Chapter 3: Using Cursor</a>
                        <a href="book-website/04-database-design-fundamentals.html">Chapter 4: Database Design</a>
                        <a href="book-website/05-advanced-data-modeling.html">Chapter 5: Advanced Data Modeling</a>
                        <a href="book-website/06-systems-design-principles.html">Chapter 6: Systems Design</a>
                        <a href="book-website/07-building-fullstack-flask.html">Chapter 7: Building Flask Apps</a>
                        <a href="book-website/08-network-troubleshooting.html">Chapter 8: Network Troubleshooting</a>
                        <a href="book-website/09-application-debugging.html">Chapter 9: Application Debugging</a>
                        <a href="book-website/10-algorithmic-thinking.html">Chapter 10: Algorithmic Thinking</a>
                        <a href="book-website/11-testing-strategies.html">Chapter 11: Testing Strategies</a>
                        <a href="book-website/12-security-fundamentals.html">Chapter 12: Security Fundamentals</a>
                        <a href="book-website/13-deployment-devops.html">Chapter 13: Deployment & DevOps</a>
                        <a href="book-website/14-advanced-topics.html">Chapter 14: Advanced Topics</a>
                    </div>
                </div>
                <a href="book-website/resources.html" class="nav-link">Resources</a>
                <a href="ai-chatbot.html" class="nav-link active">AI Chatbot</a>
                <a href="book-website/about.html" class="nav-link">About</a>
            </div>
            <div class="nav-toggle">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="main-content">
        <div class="container">
            <div class="header">
                <h1>AI RAG Chatbot</h1>
                <p>Advanced conversational AI with vector database and retrieval-augmented generation</p>
            </div>

        <div class="setup-panel">
            <h3>Setup</h3>
            <input type="password" 
                   class="api-key-input" 
                   id="apiKeyInput" 
                   placeholder="Enter your OpenAI API key (sk-...)">
            <div class="status-indicator" id="statusIndicator">
                <span class="status-waiting">⏳ Waiting for API key</span>
            </div>
        </div>

        <div class="chat-container">
            <div class="sidebar">
                <h3>Knowledge Base</h3>
                <div class="knowledge-stats">
                    <div class="stat-item">
                        <span class="stat-label">Documents:</span>
                        <span class="stat-value" id="docCount">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Chunks:</span>
                        <span class="stat-value" id="chunkCount">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Embeddings:</span>
                        <span class="stat-value" id="embeddingCount">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Conversations:</span>
                        <span class="stat-value" id="conversationCount">0</span>
                    </div>
                </div>

                <div class="upload-section">
                    <h4 style="margin-bottom: 10px; color: var(--text-color);">Add Knowledge</h4>
                    <button class="upload-button" onclick="document.getElementById('fileInput').click()">
                        📄 Upload Documents
                    </button>
                    <input type="file" id="fileInput" class="file-input" multiple accept=".txt,.md,.pdf,.json">
                    <div class="progress-bar" id="uploadProgress" style="display: none;">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="embedding-status" id="embeddingStatus"></div>
                </div>

                <div class="documents-section">
                    <h4 style="margin-bottom: 10px; color: var(--text-color);">Documents</h4>
                    <div id="documentsList" class="documents-list">
                        <div class="no-documents">No documents uploaded yet</div>
                    </div>
                    <button class="list-docs-button" onclick="chatSystem.requestDocumentList()">
                        📋 List All Documents
                    </button>
                </div>
            </div>

            <div class="chat-panel">
                <div class="chat-messages" id="chatMessages">
                    <div class="message">
                        <div class="message-avatar ai-avatar">AI</div>
                        <div class="message-content">
                            <div class="message-text">
                                Hello! I'm your AI assistant with RAG capabilities. I can learn from documents you upload and answer questions based on that knowledge. Upload some documents to get started, or ask me anything!
                            </div>
                            <div class="message-meta">System • Ready to chat</div>
                        </div>
                    </div>
                </div>

                <div class="chat-input-container">
                    <div class="chat-input-wrapper">
                        <textarea class="chat-input" 
                                  id="chatInput" 
                                  placeholder="Ask me anything..."
                                  rows="1"></textarea>
                        <button class="send-button" id="sendButton" onclick="sendMessage()">
                            Send
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== VECTOR DATABASE IMPLEMENTATION =====
        class VectorDatabase {
            constructor() {
                this.documents = JSON.parse(localStorage.getItem('rag_documents') || '[]');
                this.embeddings = JSON.parse(localStorage.getItem('rag_embeddings') || '[]');
                this.conversations = JSON.parse(localStorage.getItem('rag_conversations') || '[]');
                this.chunks = JSON.parse(localStorage.getItem('rag_chunks') || '[]');
            }

            // Calculate cosine similarity between two vectors
            cosineSimilarity(vecA, vecB) {
                if (vecA.length !== vecB.length) return 0;
                
                let dotProduct = 0;
                let normA = 0;
                let normB = 0;
                
                for (let i = 0; i < vecA.length; i++) {
                    dotProduct += vecA[i] * vecB[i];
                    normA += vecA[i] * vecA[i];
                    normB += vecB[i] * vecB[i];
                }
                
                return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
            }

            // Add document chunks with embeddings
            async addDocument(content, metadata = {}) {
                const chunks = this.chunkText(content);
                const docId = Date.now().toString();
                
                for (let i = 0; i < chunks.length; i++) {
                    const chunkId = `${docId}_${i}`;
                    const embedding = await this.getEmbedding(chunks[i]);
                    
                    this.chunks.push({
                        id: chunkId,
                        content: chunks[i],
                        metadata: { ...metadata, docId, chunkIndex: i },
                        timestamp: new Date().toISOString()
                    });
                    
                    this.embeddings.push({
                        id: chunkId,
                        vector: embedding,
                        content: chunks[i],
                        metadata
                    });
                }
                
                this.documents.push({
                    id: docId,
                    originalContent: content,
                    metadata,
                    chunkCount: chunks.length,
                    timestamp: new Date().toISOString()
                });
                
                this.save();
                return docId;
            }

            // Chunk text into smaller pieces
            chunkText(text, maxChunkSize = 1000, overlap = 200) {
                const chunks = [];
                const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
                
                let currentChunk = '';
                let currentSize = 0;
                
                for (const sentence of sentences) {
                    const sentenceSize = sentence.trim().length;
                    
                    if (currentSize + sentenceSize > maxChunkSize && currentChunk.length > 0) {
                        chunks.push(currentChunk.trim());
                        
                        // Create overlap
                        const words = currentChunk.split(' ');
                        const overlapWords = words.slice(-Math.floor(overlap / 10));
                        currentChunk = overlapWords.join(' ') + ' ' + sentence.trim();
                        currentSize = currentChunk.length;
                    } else {
                        currentChunk += (currentChunk ? '. ' : '') + sentence.trim();
                        currentSize = currentChunk.length;
                    }
                }
                
                if (currentChunk.trim().length > 0) {
                    chunks.push(currentChunk.trim());
                }
                
                return chunks.length > 0 ? chunks : [text];
            }

            // Get embedding from OpenAI
            async getEmbedding(text) {
                try {
                    if (!window.openaiApiKey || !window.openaiApiKey.startsWith('sk-')) {
                        throw new Error('Invalid or missing OpenAI API key');
                    }

                    const response = await fetch('https://api.openai.com/v1/embeddings', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${window.openaiApiKey}`,
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            input: text,
                            model: 'text-embedding-3-small'
                        })
                    });

                    const data = await response.json();
                    
                    // Check if the API response was successful
                    if (!response.ok) {
                        throw new Error(data.error?.message || `API request failed with status ${response.status}`);
                    }
                    
                    // Validate that we have the expected data structure
                    if (!data.data || !data.data[0] || !data.data[0].embedding) {
                        throw new Error('Invalid response format from OpenAI API');
                    }
                    
                    return data.data[0].embedding;
                } catch (error) {
                    console.error('Error getting embedding:', error);
                    // Return a random vector as fallback (for demo purposes)
                    return Array.from({length: 1536}, () => Math.random() - 0.5);
                }
            }

            // Search for similar content
            async search(query, topK = 5) {
                if (this.embeddings.length === 0) return [];
                
                const queryEmbedding = await this.getEmbedding(query);
                const similarities = this.embeddings.map(item => ({
                    ...item,
                    similarity: this.cosineSimilarity(queryEmbedding, item.vector)
                }));
                
                return similarities
                    .sort((a, b) => b.similarity - a.similarity)
                    .slice(0, topK)
                    .filter(item => item.similarity > 0.3); // Minimum similarity threshold
            }

            // Get all documents with metadata
            getAllDocuments() {
                return this.documents.map(doc => ({
                    id: doc.id,
                    filename: doc.metadata.filename || 'Unknown',
                    type: doc.metadata.fileType || doc.metadata.type || 'text',
                    size: doc.metadata.fileSize || doc.originalContent.length,
                    chunkCount: doc.chunkCount,
                    timestamp: doc.timestamp,
                    preview: doc.originalContent.substring(0, 200) + (doc.originalContent.length > 200 ? '...' : '')
                }));
            }

            // Search within specific document
            searchInDocument(docId, query) {
                const relevantChunks = this.chunks.filter(chunk => 
                    chunk.metadata.docId === docId && 
                    chunk.content.toLowerCase().includes(query.toLowerCase())
                );
                
                return relevantChunks.map(chunk => ({
                    content: chunk.content,
                    chunkIndex: chunk.metadata.chunkIndex,
                    preview: this.highlightText(chunk.content, query)
                }));
            }

            // Highlight search terms in text
            highlightText(text, query) {
                if (!query) return text;
                const regex = new RegExp(`(${query})`, 'gi');
                return text.replace(regex, '**$1**');
            }

            // Save conversation
            saveConversation(userMessage, aiResponse, sources = []) {
                this.conversations.push({
                    id: Date.now().toString(),
                    userMessage,
                    aiResponse,
                    sources,
                    timestamp: new Date().toISOString()
                });
                this.save();
            }

            // Persist to localStorage
            save() {
                localStorage.setItem('rag_documents', JSON.stringify(this.documents));
                localStorage.setItem('rag_embeddings', JSON.stringify(this.embeddings));
                localStorage.setItem('rag_conversations', JSON.stringify(this.conversations));
                localStorage.setItem('rag_chunks', JSON.stringify(this.chunks));
                this.updateStats();
            }

            // Update UI stats
            updateStats() {
                document.getElementById('docCount').textContent = this.documents.length;
                document.getElementById('chunkCount').textContent = this.chunks.length;
                document.getElementById('embeddingCount').textContent = this.embeddings.length;
                document.getElementById('conversationCount').textContent = this.conversations.length;
                this.updateDocumentsList();
            }

            // Update the documents list in the sidebar
            updateDocumentsList() {
                const documentsList = document.getElementById('documentsList');
                
                if (this.documents.length === 0) {
                    documentsList.innerHTML = '<div class="no-documents">No documents uploaded yet</div>';
                    return;
                }

                documentsList.innerHTML = this.documents.map(doc => {
                    const filename = doc.metadata.filename || 'Unknown';
                    const uploadDate = new Date(doc.timestamp).toLocaleDateString();
                    const sizeFormatted = doc.metadata.fileSize > 1024 ? 
                        `${(doc.metadata.fileSize / 1024).toFixed(1)}KB` : 
                        `${doc.metadata.fileSize || doc.originalContent.length} bytes`;
                    
                    return `
                        <div class="document-item">
                            <div class="document-name">${filename}</div>
                            <div class="document-meta">${sizeFormatted} • ${doc.chunkCount} chunks • ${uploadDate}</div>
                        </div>
                    `;
                }).join('');
            }

            // Clear all data
            clear() {
                this.documents = [];
                this.embeddings = [];
                this.conversations = [];
                this.chunks = [];
                localStorage.removeItem('rag_documents');
                localStorage.removeItem('rag_embeddings');
                localStorage.removeItem('rag_conversations');
                localStorage.removeItem('rag_chunks');
                this.updateStats();
            }
        }

        // ===== RAG CHAT SYSTEM =====
        class RAGChatSystem {
            constructor() {
                this.vectorDB = new VectorDatabase();
                this.isProcessing = false;
                this.initializeEventListeners();
                this.vectorDB.updateStats();
            }

            initializeEventListeners() {
                // API key input
                document.getElementById('apiKeyInput').addEventListener('input', (e) => {
                    window.openaiApiKey = e.target.value;
                    this.updateStatus();
                });

                // Chat input
                document.getElementById('chatInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });

                // File upload
                document.getElementById('fileInput').addEventListener('change', (e) => {
                    this.handleFileUpload(e.target.files);
                });

                // Auto-resize textarea
                document.getElementById('chatInput').addEventListener('input', (e) => {
                    e.target.style.height = 'auto';
                    e.target.style.height = Math.min(e.target.scrollHeight, 120) + 'px';
                });
            }

            updateStatus() {
                const indicator = document.getElementById('statusIndicator');
                if (window.openaiApiKey && window.openaiApiKey.startsWith('sk-')) {
                    indicator.innerHTML = '<span class="status-ready">✅ API Key Configured</span>';
                    indicator.className = 'status-indicator status-ready';
                    
                    // Add demo content when API key is first configured
                    this.addDemoContentIfNeeded();
                } else {
                    indicator.innerHTML = '<span class="status-waiting">⏳ Waiting for API key</span>';
                    indicator.className = 'status-indicator status-waiting';
                }
            }

            addDemoContentIfNeeded() {
                // Only add demo content if no documents exist yet
                if (this.vectorDB.documents.length === 0) {
                    const demoContent = `
                    Welcome to the AI RAG Chatbot! This system combines advanced conversational AI with a vector database for retrieval-augmented generation.
                    
                    Key Features:
                    - Vector similarity search using embeddings
                    - Document chunking and processing
                    - Persistent knowledge base storage
                    - Real-time conversation tracking
                    - Scalable RAG implementation
                    
                    How it works:
                    1. Upload documents to build your knowledge base
                    2. The system creates embeddings for text chunks
                    3. When you ask questions, it finds relevant content
                    4. AI generates responses using the retrieved context
                    5. All conversations are saved for continuous improvement
                    
                    Technical Implementation:
                    - Uses OpenAI's text-embedding-3-small for embeddings
                    - Cosine similarity for vector search
                    - LocalStorage for client-side persistence
                    - Responsive design for all devices
                    - Pure JavaScript implementation
                    `;
                    
                    // Don't wait for this to complete
                    this.vectorDB.addDocument(demoContent, {
                        filename: 'demo_content.txt',
                        source: 'system',
                        type: 'documentation'
                    });
                }
            }

            async handleFileUpload(files) {
                if (!window.openaiApiKey || !window.openaiApiKey.startsWith('sk-')) {
                    this.showError('Please configure a valid OpenAI API key first.');
                    return;
                }

                const progressBar = document.getElementById('uploadProgress');
                const progressFill = document.getElementById('progressFill');
                const status = document.getElementById('embeddingStatus');
                
                progressBar.style.display = 'block';
                status.textContent = 'Processing files...';

                let processedCount = 0;
                const totalFiles = files.length;

                for (const file of files) {
                    try {
                        const content = await this.readFile(file);
                        const metadata = {
                            filename: file.name,
                            fileType: file.type,
                            fileSize: file.size,
                            uploadDate: new Date().toISOString()
                        };

                        status.textContent = `Processing ${file.name}...`;
                        await this.vectorDB.addDocument(content, metadata);
                        
                        processedCount++;
                        const progress = (processedCount / totalFiles) * 100;
                        progressFill.style.width = progress + '%';
                        
                    } catch (error) {
                        console.error('Error processing file:', file.name, error);
                        this.showError(`Error processing ${file.name}: ${error.message}`);
                    }
                }

                status.textContent = `Successfully processed ${processedCount} file(s)`;
                setTimeout(() => {
                    progressBar.style.display = 'none';
                    status.textContent = '';
                }, 2000);

                // Clear file input
                document.getElementById('fileInput').value = '';
            }

            readFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = (e) => reject(new Error('Failed to read file'));
                    reader.readAsText(file);
                });
            }

            async sendMessage() {
                if (this.isProcessing) return;
                
                const input = document.getElementById('chatInput');
                const message = input.value.trim();
                
                if (!message) return;
                if (!window.openaiApiKey || !window.openaiApiKey.startsWith('sk-')) {
                    this.showError('Please configure a valid OpenAI API key first.');
                    return;
                }

                this.isProcessing = true;
                input.value = '';
                input.style.height = 'auto';
                
                // Add user message
                this.addMessage(message, 'user');
                
                // Show typing indicator
                const typingId = this.addMessage('', 'ai', true);
                
                try {
                    // Search for relevant context
                    const relevantChunks = await this.vectorDB.search(message, 5);
                    
                    // Generate AI response
                    const response = await this.generateResponse(message, relevantChunks);
                    
                    // Remove typing indicator and add response
                    this.removeMessage(typingId);
                    this.addMessage(response.text, 'ai', false, response.sources);
                    
                    // Save conversation
                    this.vectorDB.saveConversation(message, response.text, response.sources);
                    
                } catch (error) {
                    this.removeMessage(typingId);
                    this.addMessage('Sorry, I encountered an error processing your request. Please check your API key and try again.', 'ai');
                    console.error('Error generating response:', error);
                } finally {
                    this.isProcessing = false;
                    document.getElementById('sendButton').disabled = false;
                }
            }

            async generateResponse(userMessage, relevantChunks) {
                // Check if user is asking about documents in the knowledge base
                const isDocumentQuery = /list.*documents?|show.*documents?|what.*documents?|documents.*knowledge.*base/i.test(userMessage);
                
                if (isDocumentQuery) {
                    return this.generateDocumentListResponse();
                }

                // Check if user is asking for relevant lines about a specific topic
                const isRelevantLinesQuery = /relevant.*lines?|show.*lines?|find.*lines?|lines.*about/i.test(userMessage);
                
                if (isRelevantLinesQuery && relevantChunks.length > 0) {
                    return this.generateRelevantLinesResponse(userMessage, relevantChunks);
                }

                const context = relevantChunks.map(chunk => chunk.content).join('\n\n');
                const sources = relevantChunks.map(chunk => ({
                    content: chunk.content.substring(0, 100) + '...',
                    similarity: chunk.similarity,
                    metadata: chunk.metadata
                }));

                // Add document information to context if available
                const documents = this.vectorDB.getAllDocuments();
                const documentContext = documents.length > 0 ? 
                    `\n\nAvailable documents in knowledge base:\n${documents.map(doc => `- ${doc.filename} (${doc.type}, ${doc.chunkCount} chunks)`).join('\n')}` : '';

                const systemPrompt = `You are a helpful AI assistant with access to a knowledge base. Use the provided context to answer questions accurately and comprehensively.

Context from knowledge base:
${context}${documentContext}

Instructions:
- Use the context provided to answer the user's question
- Format your responses using proper markdown syntax with headers, lists, bold text, and code blocks
- If the context doesn't contain relevant information, say so and provide a general helpful response
- Be specific and cite relevant information from the context
- If you're unsure about something, express that uncertainty
- Provide actionable and detailed responses when possible
- Use proper indentation and formatting for code examples
- Structure your responses with clear sections using headers (## or ###)
- Use bullet points or numbered lists for multiple items
- Emphasize important terms with **bold** or *italic* text
- Use \`code\` formatting for technical terms and code snippets`;

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${window.openaiApiKey}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: userMessage }
                        ],
                        temperature: 0.7,
                        max_tokens: 1000
                    })
                });

                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error?.message || 'Failed to generate response');
                }

                return {
                    text: data.choices[0].message.content,
                    sources: sources
                };
            }

            generateDocumentListResponse() {
                const documents = this.vectorDB.getAllDocuments();
                
                if (documents.length === 0) {
                    return {
                        text: `# Knowledge Base Documents

No documents have been uploaded to the knowledge base yet.

## Getting Started
1. Click **"📄 Upload Documents"** in the sidebar
2. Select text files, markdown files, or JSON documents
3. Wait for processing to complete
4. Start asking questions about your uploaded content!

## Supported Formats
- **Text files** (.txt)
- **Markdown** (.md) 
- **JSON** (.json)
- **PDF** (.pdf) *(experimental)*`,
                        sources: []
                    };
                }

                let response = `# Knowledge Base Documents

Found **${documents.length}** document${documents.length === 1 ? '' : 's'} in the knowledge base:

`;

                documents.forEach((doc, index) => {
                    const uploadDate = new Date(doc.timestamp).toLocaleDateString();
                    const sizeFormatted = doc.size > 1024 ? `${(doc.size / 1024).toFixed(1)}KB` : `${doc.size} bytes`;
                    
                    response += `## ${index + 1}. ${doc.filename}

- **Type**: ${doc.type}
- **Size**: ${sizeFormatted}
- **Chunks**: ${doc.chunkCount}
- **Uploaded**: ${uploadDate}

### Preview:
\`\`\`
${doc.preview}
\`\`\`

`;
                });

                response += `## Knowledge Base Statistics
- **Total Documents**: ${documents.length}
- **Total Chunks**: ${this.vectorDB.chunks.length}
- **Total Embeddings**: ${this.vectorDB.embeddings.length}
- **Conversations**: ${this.vectorDB.conversations.length}

You can ask me questions about any of these documents, and I'll search through their content to provide relevant answers!`;

                return {
                    text: response,
                    sources: documents.map(doc => ({
                        content: doc.preview,
                        similarity: 1.0,
                        metadata: { filename: doc.filename, type: doc.type }
                    }))
                };
            }

            generateRelevantLinesResponse(userMessage, relevantChunks) {
                // Extract key terms from the user message
                const keyTerms = userMessage.toLowerCase()
                    .replace(/relevant.*lines?|show.*lines?|find.*lines?|lines.*about/gi, '')
                    .replace(/[^\w\s]/g, '')
                    .split(/\s+/)
                    .filter(term => term.length > 2);

                let response = `# Relevant Content Found

Found **${relevantChunks.length}** relevant section${relevantChunks.length === 1 ? '' : 's'} across your documents:

`;

                relevantChunks.forEach((chunk, index) => {
                    const docId = chunk.metadata.docId;
                    const document = this.vectorDB.documents.find(doc => doc.id === docId);
                    const filename = document?.metadata?.filename || 'Unknown Document';
                    const similarity = (chunk.similarity * 100).toFixed(1);
                    
                    response += `## ${index + 1}. From "${filename}" (${similarity}% match)

### Content:
\`\`\`
${chunk.content}
\`\`\`

`;
                });

                // Add search suggestions
                response += `## 💡 Search Tips

You can ask more specific questions like:
- *"What does this document say about [specific topic]?"*
- *"Find information about [concept] in the knowledge base"*
- *"Show me examples of [technique] from the documents"*

The higher the similarity percentage, the more relevant the content is to your query!`;

                return {
                    text: response,
                    sources: relevantChunks.map(chunk => ({
                        content: chunk.content.substring(0, 150) + '...',
                        similarity: chunk.similarity,
                        metadata: chunk.metadata
                    }))
                };
            }

            addMessage(content, sender, isTyping = false, sources = []) {
                const messagesContainer = document.getElementById('chatMessages');
                const messageId = Date.now().toString();
                
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message';
                messageDiv.id = messageId;
                
                const avatarDiv = document.createElement('div');
                avatarDiv.className = `message-avatar ${sender}-avatar`;
                avatarDiv.textContent = sender === 'user' ? 'U' : 'AI';
                
                const contentDiv = document.createElement('div');
                contentDiv.className = 'message-content';
                
                const textDiv = document.createElement('div');
                textDiv.className = 'message-text';
                
                if (isTyping) {
                    textDiv.innerHTML = '<div class="loading"><div class="spinner"></div>Thinking...</div>';
                } else {
                    // Format content as markdown for AI responses
                    if (sender === 'ai') {
                        textDiv.innerHTML = this.formatMarkdown(content);
                    } else {
                        textDiv.textContent = content;
                    }
                }
                
                const metaDiv = document.createElement('div');
                metaDiv.className = 'message-meta';
                metaDiv.textContent = `${sender === 'user' ? 'You' : 'AI'} • ${new Date().toLocaleTimeString()}`;
                
                contentDiv.appendChild(textDiv);
                contentDiv.appendChild(metaDiv);
                
                // Add sources if available
                if (sources.length > 0) {
                    const sourcesDiv = document.createElement('div');
                    sourcesDiv.className = 'sources';
                    
                    const titleDiv = document.createElement('div');
                    titleDiv.className = 'sources-title';
                    titleDiv.textContent = 'Sources:';
                    sourcesDiv.appendChild(titleDiv);
                    
                    sources.forEach((source, index) => {
                        const sourceDiv = document.createElement('div');
                        sourceDiv.className = 'source-item';
                        sourceDiv.textContent = `${index + 1}. ${source.content} (similarity: ${(source.similarity * 100).toFixed(1)}%)`;
                        sourcesDiv.appendChild(sourceDiv);
                    });
                    
                    contentDiv.appendChild(sourcesDiv);
                }
                
                messageDiv.appendChild(avatarDiv);
                messageDiv.appendChild(contentDiv);
                
                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                
                return messageId;
            }

            removeMessage(messageId) {
                const message = document.getElementById(messageId);
                if (message) {
                    message.remove();
                }
            }

            formatMarkdown(text) {
                // Basic markdown formatting for AI responses
                let formatted = text
                    // Headers
                    .replace(/^### (.*$)/gm, '<h3>$1</h3>')
                    .replace(/^## (.*$)/gm, '<h2>$1</h2>')
                    .replace(/^# (.*$)/gm, '<h1>$1</h1>')
                    
                    // Bold and italic
                    .replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>')
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    
                    // Code blocks
                    .replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>')
                    .replace(/`(.*?)`/g, '<code>$1</code>')
                    
                    // Lists
                    .replace(/^\d+\.\s+(.*$)/gm, '<li>$1</li>')
                    .replace(/^[-*+]\s+(.*$)/gm, '<li>$1</li>')
                    
                    // Line breaks
                    .replace(/\n\n/g, '</p><p>')
                    .replace(/\n/g, '<br>');

                // Wrap in paragraph tags and handle lists
                formatted = '<p>' + formatted + '</p>';
                
                // Fix list formatting
                formatted = formatted
                    .replace(/<p>(<li>.*?<\/li>)<\/p>/g, '<ul>$1</ul>')
                    .replace(/<\/li><br><li>/g, '</li><li>')
                    .replace(/<p><\/p>/g, '');

                return formatted;
            }

            showError(message) {
                const messagesContainer = document.getElementById('chatMessages');
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.textContent = message;
                messagesContainer.appendChild(errorDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                
                setTimeout(() => {
                    errorDiv.remove();
                }, 5000);
            }

            requestDocumentList() {
                // Simulate sending a message to list documents
                const input = document.getElementById('chatInput');
                input.value = 'list the documents in knowledge base';
                this.sendMessage();
            }
        }

        // ===== INITIALIZATION =====
        let chatSystem;

        document.addEventListener('DOMContentLoaded', () => {
            chatSystem = new RAGChatSystem();
            
            // Global functions for HTML onclick handlers
            window.sendMessage = () => chatSystem.sendMessage();
            
            // Demo content will be added when a valid API key is provided
        });

        // Navigation functionality  
        function setupNavigation() {
            const navToggle = document.querySelector('.nav-toggle');
            const navMenu = document.querySelector('.nav-menu');
            const navbar = document.querySelector('.navbar');
            
            // Mobile menu toggle
            if (navToggle && navMenu) {
                navToggle.addEventListener('click', () => {
                    navMenu.classList.toggle('active');
                    navToggle.classList.toggle('active');
                });
            }
            
            // Close mobile menu when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.navbar')) {
                    navMenu?.classList.remove('active');
                    navToggle?.classList.remove('active');
                }
            });
            
            // Scroll behavior for navbar
            let lastScrollY = window.scrollY;
            
            window.addEventListener('scroll', () => {
                const currentScrollY = window.scrollY;
                
                if (navbar) {
                    // Add scrolled class for styling
                    if (currentScrollY > 20) {
                        navbar.classList.add('scrolled');
                    } else {
                        navbar.classList.remove('scrolled');
                    }
                    
                    // Hide/show navbar on scroll
                    if (currentScrollY > lastScrollY && currentScrollY > 100) {
                        navbar.style.transform = 'translateY(-100%)';
                    } else {
                        navbar.style.transform = 'translateY(0)';
                    }
                }
                
                lastScrollY = currentScrollY;
            });
        }

        // Initialize navigation on page load
        document.addEventListener('DOMContentLoaded', () => {
            setupNavigation();
        });
    </script>
        </div>
    </main>
</body>
</html>
